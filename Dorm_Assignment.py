# -*- coding: utf-8 -*-
"""SUBMISSION (1).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rDY34scskCbjTkWYWw8Sm98Zn-HZ4ppp
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
import ast
import csv

class Student:
    def __init__(self, ruid, accessibility_need, max_price, preferred_hall_ids, preferred_residence_type, roommate_preference):
        self.ruid = ruid
        self.accessibility_need = accessibility_need
        self.max_price = max_price
        self.preferred_hall_ids = preferred_hall_ids
        self.preferred_residence_type = preferred_residence_type
        self.roommate_preference = roommate_preference
        self.matched_room = None
        self.preference_index = 0

    def propose_until_matched(self, halls, unmatched_students):
        for hall in halls.values():
            old_student = hall.accept_student(self, unmatched_students)
            if old_student is None:
                return None
        return self

class Hall:
    def __init__(self, hall_id, rooms):
        self.hall_id = hall_id
        self.rooms = rooms
        self.assigned_students = {}

    def accept_student(self, student, unmatched_students):
        for room in self.rooms:
            if room.is_eligible(student):
                if room.assign_student(student):
                    return None
        return student

class Room:
    def __init__(self, room_no, room_id, max_price, max_occupancy, has_accessibility_ramps, residence_type):
        self.room_no = room_no
        self.room_id = room_id
        self.max_price = max_price
        self.max_occupancy = max_occupancy
        self.has_accessibility_ramps = has_accessibility_ramps
        self.residence_type = residence_type
        self.occupants = []
        self.hall_name = ""
        self.building_id = ""

    def is_eligible(self, student):
        if student.max_price < self.max_price:
            return False
        if student.accessibility_need and not self.has_accessibility_ramps:
            return False
        if student.preferred_residence_type and student.preferred_residence_type != self.residence_type:
            return False
        return True

    def assign_student(self, student):
        if len(self.occupants) < self.max_occupancy:
            self.occupants.append(student)
            student.matched_room = self
            return True
        return False

def deferred_acceptance(students, halls):
    unmatched_students = {s.ruid: s for s in students if s.matched_room is None}
    available_students = list(unmatched_students.values())

    max_iterations = len(students) * 10
    iteration = 0

    while available_students and iteration < max_iterations:
        iteration += 1
        student = available_students.pop()

        if student.roommate_preference in unmatched_students:
            roommate = unmatched_students[student.roommate_preference]
            for hall in halls.values():
                for room in hall.rooms:
                    if room.has_room_for_both(student, roommate) and room.is_eligible(student) and room.is_eligible(roommate):
                        room.assign_student(student)
                        room.assign_student(roommate)
                        unmatched_students.pop(student.ruid, None)
                        unmatched_students.pop(roommate.ruid, None)
                        break

        old_student = student.propose_until_matched(halls, unmatched_students)
        if old_student and old_student != student:
            available_students.append(old_student)

    return students, halls

def load_data(students_df, rooms_df):
    rooms_df["building_id"] = rooms_df["building_id"].fillna("UNKNOWN")
    students = []
    for _, row in students_df.iterrows():
        preferred_hall_ids = []
        student = Student(
            ruid=str(row["RUID"]).strip(),
            accessibility_need=bool(row["accessibility_need"]),
            max_price=int(row["max_price"]),
            preferred_hall_ids=preferred_hall_ids,
            preferred_residence_type=str(row["preferred_residence_type"]).strip(),
            roommate_preference=str(row["roommate_preferences"]).strip() if pd.notna(row["roommate_preferences"]) else None
        )
        students.append(student)
    halls = {}
    for _, row in rooms_df.iterrows():
        room = Room(
            room_no=str(row["room_number"]).strip(),
            room_id=str(row["room_id"]).strip(),
            max_price=int(row["price"]),
            max_occupancy=int(row["max_room_occupancy"]),
            has_accessibility_ramps=bool(row["has_accessibility_ramps"]),
            residence_type=str(row["residence_type"]).strip()
        )
        room.hall_name = str(row["hall_name"]).strip()
        room.building_id = str(row["building_id"]).strip()
        room.hall_id = str(row["hall_id"]).strip()
        hall_id = str(row["hall_id"]).strip()
        if hall_id not in halls:
            halls[hall_id] = Hall(hall_id, [])
        halls[hall_id].rooms.append(room)
    return students, halls

def run_matching_algorithm(students_df, rooms_df, output_file="dorm_assignments.csv"):
    students, halls = load_data(students_df, rooms_df)
    matched_students, matched_halls = deferred_acceptance(students, halls)
    with open(output_file, mode="w", newline="") as file:
        writer = csv.writer(file)
        writer.writerow(["", "RUID", "Assigned Rooms"])
        for index, student in enumerate(matched_students):
            if student.matched_room:
                room = student.matched_room
                assigned_room = [room.hall_id, room.building_id, room.room_id]
            else:
                assigned_room = ["nan", "nan", "nan"]
            writer.writerow([index, student.ruid, str(assigned_room)])
    return matched_students, matched_halls

students_df = pd.read_csv("/content/drive/MyDrive/Group C Dorms Project/datasetA_with_roommate_pref.csv", usecols=[
    'RUID', 'accessibility_need', 'max_price', 'preferred_hall_ids', 'preferred_residence_type', 'roommate_preferences'
])

rooms_df = pd.read_csv("/content/drive/MyDrive/Group C Dorms Project/final_room_data.csv", usecols=[
    'room_number', 'room_id', 'price', 'max_room_occupancy', 'has_accessibility_ramps', 'residence_type', 'hall_name', 'building_id', 'hall_id'
])

output_path = "/content/drive/MyDrive/Group C Dorms Project/allocateddskjhfskdfjh.csv"
matched_students, matched_halls = run_matching_algorithm(students_df, rooms_df, output_file=output_path)